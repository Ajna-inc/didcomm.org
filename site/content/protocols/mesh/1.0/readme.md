---
title: Mesh
publisher: vinaysingh8866
license: MIT
piuri: https://didcomm.org/mesh/1.0
status: Proposed
summary: A DIDComm v2 protocol for decentralized peer-to-peer mesh networking over BLE, LoRa, WiFi, and Internet transports with Ed25519-signed announcements, topology-aware routing, compact binary encoding, session-key encryption, and cross-cluster gateway bridging.
tags: [mesh, ble, lora, wifi, p2p, relay, offline, gateway]
authors:
  - name: Vinay Singh
    email: vinay@ajna.inc

---

## Summary

The Mesh Networking Protocol enables DIDComm agents to form ad-hoc mesh networks across heterogeneous transports without requiring centralized infrastructure. Nodes discover peers via Ed25519-signed announcements, build a topology graph, and relay encrypted DIDComm messages across multiple hops. Gateway nodes bridge local mesh clusters to the global internet, enabling cross-cluster communication while preserving end-to-end encryption and identity privacy.

Key capabilities:
- Ed25519-signed peer announcements with routing ID binding
- Binary wire format optimized for constrained transports (22-byte packet header)
- Compact session-key encryption envelope derived from DIDComm X25519 keys (21-byte overhead)
- TTL-based controlled flooding with degree-adaptive jitter and probabilistic relay
- Topology-aware shortest-path routing (BFS) for directed messages
- Multi-transport support: BLE, LoRa, WiFi, and Internet (WebSocket)
- Gateway bridging between local mesh clusters via DIDComm mediation and forwarding
- Connection-record-based cross-cluster routing with no public identity directory
- Packet deduplication via LRU cache
- Zstd dictionary compression for bandwidth-constrained links
- Graceful leave notifications
- Fragment support for MTU-constrained transports

---

## Goals

- Enable DIDComm messaging between agents with no internet connectivity
- Provide multi-hop relay so agents beyond direct radio range can communicate
- Support heterogeneous transports (BLE, LoRa, WiFi, Internet) in the same mesh with automatic transport selection
- Fit common DIDComm messages into a single LoRa frame (233 bytes) via binary encoding, compression, and compact encryption
- Bridge isolated mesh clusters globally via gateway nodes using standard DIDComm mediation and forwarding
- Prevent topology spoofing through Ed25519 signature verification and routing ID binding
- Minimize broadcast storms via TTL capping, deduplication, probabilistic relay, and degree-adaptive jitter
- Preserve DIDComm's privacy model: no public user directory, no unsolicited messaging, no identity tracking

---

## Roles

- `node`: Any agent participating in the mesh. All nodes are equal peers with no central coordinator. Every node can act as a relay.
- `gateway`: A node with both a local mesh transport (BLE/LoRa) and an internet connection. Gateways run a DIDComm mediator service and bridge local mesh traffic to remote clusters.

In practice, nodes take on transient behavioral roles:
- **announcer**: Broadcasting its presence and neighbor list
- **relay**: Forwarding packets on behalf of others
- **sender**: Originating a directed or broadcast message
- **recipient**: Final destination of a directed message
- **gateway**: Bridging between local mesh and internet transports

---

## Identifiers

### Routing ID

Each node is identified by an 8-byte **Routing ID** derived from its Ed25519 public key:

```
routing_id = SHA256(ed25519_public_key)[0..8]
```

Routing IDs are compact identifiers used in packet headers and topology tracking. They are cryptographically bound to the signing key, verified during announcement processing.

#### Transport Prefix Convention

The first 4 bytes of a routing ID MAY indicate the node's preferred transport:

| Prefix (ASCII) | Hex | Transport | Description |
|----------------|-----|-----------|-------------|
| `MESH` | `0x4D455348` | LoRa | Meshtastic radio node |
| `WIFI` | `0x57494649` | WiFi | LAN peer discovered via mDNS |
| `INET` | `0x494E4554` | Internet | Node reachable via WebSocket/HTTP |
| *(other)* | — | BLE | Default for proximity-discovered peers |

Implementations use these prefixes to select the preferred transport when multiple paths exist to a destination. Prefixed routing IDs are generated by combining the 4-byte prefix with a 4-byte identifier (e.g., Meshtastic node number, IP hash).

Standard routing IDs derived from Ed25519 keys do not carry a prefix and default to BLE transport preference.

### DID

The mesh layer does NOT include or require DIDs. Identity exchange and connection establishment are handled separately via the [Out-of-Band](https://didcomm.org/out-of-band/2.0) protocol. DIDs are never broadcast over the mesh. Only 8-byte routing IDs appear in packet headers.

---

## Encoding

The protocol defines two wire encodings. Implementations MUST support binary encoding. JSON encoding is OPTIONAL and intended for debugging, logging, and internet transports where bandwidth is not constrained.

### Binary Encoding (Primary)

Binary encoding is used on all constrained transports (BLE, LoRa, WiFi mesh). All multi-byte integers are big-endian.

#### Binary Relay Packet (22-byte header)

```
Offset  Size  Field
0x00    1B    flags
              [7:6] version (0b00 = v1)
              [5]   is_handshake
              [4]   is_directed
              [3]   is_fragment
              [2]   requires_ack
              [1:0] reserved
0x01    1B    ttl
0x02    4B    packet_id
0x06    8B    sender_routing_id
0x0E    8B    dest_routing_id (0x00 for broadcast)
0x16    ...   payload (compact envelope or raw packed message)
```

Total header: 22 bytes.

#### Binary Announcement

```
Offset    Size    Field
0x00      1B      type marker (0x04)
0x01      8B      routing_id
0x09      32B     signing_key (Ed25519 public key)
0x29      1B      neighbor_count (N)
0x2A      8B*N    neighbor routing_ids
0x2A+8N   8B      timestamp (ms since Unix epoch, big-endian)
          64B     signature (Ed25519)
```

Sizes by neighbor count:

| Neighbors | Total Size | Fits LoRa (233B)? |
|-----------|-----------|-------------------|
| 0 | 114 bytes | Yes |
| 5 | 154 bytes | Yes |
| 10 | 194 bytes | Yes |
| 20 | 274 bytes | No (2 frames) |

#### Binary Leave

```
Offset  Size  Field
0x00    1B    type marker (0x05)
0x01    8B    routing_id
0x09    8B    timestamp (big-endian)
0x11    64B   signature (Ed25519)
```

Total: 81 bytes.

### JSON Encoding (Debug / Internet)

JSON encoding wraps messages in the standard DIDComm v2 message structure. It is used on internet transports and for diagnostic logging.

All mesh messages use the namespace: `https://didcomm.org/mesh/1.0/<message-name>`

JSON representations are defined in the [Message Reference](#message-reference) section.

---

## Compact Encryption Envelope

For directed messages between peers that have completed a DIDComm key exchange, the protocol defines a compact encryption envelope that replaces the full DIDComm JWE (300-500 bytes overhead) with a minimal authenticated encryption wrapper (21 bytes overhead).

### Session Key Derivation

Both peers independently derive an identical symmetric session key from their existing DIDComm X25519 key agreement keys. No additional key exchange is required.

```
shared_secret = X25519(our_private, their_public)

salt = SHA256(sort_lexicographic(our_did, their_did))

session_material = HKDF-SHA256(
    ikm:    shared_secret,
    salt:   salt,
    info:   "ajna-mesh-session-v1",
    length: 64
)

session_key  = session_material[0..32]   // AES-256-GCM key
nonce_mask   = session_material[32..64]  // For nonce derivation
```

The session key is derived from the same ECDH shared secret that DIDComm uses internally. Both sides compute an identical key because `X25519(A_private, B_public) == X25519(B_private, A_public)`. The sorted DID concatenation ensures both sides use the same salt regardless of who initiates.

### Counter-Based Nonce

The 12-byte AES-GCM nonce is derived from a monotonic counter, avoiding the need to transmit the nonce:

```
nonce[0]      = direction_bit (0 = lexicographically-first DID is sender, 1 = other)
nonce[1..4]   = 0x00
nonce[4..8]   = counter (big-endian uint32)
nonce[8..12]  = nonce_mask[0..4]
```

The `direction_bit` prevents nonce reuse when both peers use the same counter value. Each peer maintains a separate send counter per session.

### Compact Envelope Wire Format

```
Offset  Size  Field
0x00    1B    envelope_version (0x01)
0x01    4B    counter (big-endian uint32)
0x05    ...   ciphertext (AES-256-GCM)
-16B    16B   authentication tag (appended to ciphertext)
```

Total overhead: 5 bytes header + 16 bytes authentication tag = **21 bytes**.

### Applicability

| Scenario | Envelope | Reason |
|----------|----------|--------|
| Paired peer over BLE/LoRa/WiFi | Compact | Session key available, bandwidth constrained |
| First contact (no prior key exchange) | Full DIDComm JWE | No session key yet |
| Internet transport (gateway-to-gateway) | Full DIDComm JWE | Bandwidth unconstrained, interoperability |
| Broadcast messages | None (signed plaintext) | All nodes must read |

---

## Compression

Implementations SHOULD compress the plaintext payload before encryption using a pre-trained zstd dictionary when available. The compress-then-encrypt ordering is mandatory — encrypted data cannot be compressed.

The compression dictionary is trained on representative DIDComm protocol messages and embedded in all nodes as a static artifact (approximately 32 KB). Both peers must use the same dictionary version.

Compression is applied inside the compact envelope:

```
plaintext → zstd_compress(dictionary) → AES-256-GCM encrypt → binary packet header
```

Expected compression ratios on structured DIDComm JSON:

| Input Size | Compressed | Ratio |
|-----------|-----------|-------|
| 150 bytes (trust ping) | ~50 bytes | 3x |
| 300 bytes (basic message) | ~100 bytes | 3x |
| 430 bytes (100-char message) | ~140 bytes | 3x |

### LoRa Single-Frame Budget

With binary encoding, compact envelope, and compression, the effective payload capacity of a single LoRa frame (233-byte Meshtastic MTU) is:

```
Meshtastic MTU:               233 bytes
- Protobuf framing:            -5 bytes
= Available:                  228 bytes

Binary packet header:          22 bytes
Compact envelope overhead:     21 bytes
= Available for compressed
  plaintext:                  185 bytes

At 3x compression ratio:     ~555 bytes equivalent uncompressed
```

Most common DIDComm messages (trust ping, short text messages, blockchain queries) fit in a single LoRa frame.

---

## Transport

The mesh protocol is transport-agnostic at the protocol level. Implementations SHOULD support multiple transports simultaneously and select the appropriate transport based on the destination's routing ID prefix and availability.

### Transport Selection

When sending a directed message to a known routing ID, implementations SHOULD prefer the transport matching the destination's prefix, falling back through alternatives:

| Destination Prefix | Preference Order |
|--------------------|-----------------|
| `MESH` (LoRa) | LoRa > BLE > WiFi > Internet |
| `WIFI` | WiFi > BLE > Internet > LoRa |
| `INET` (Internet) | Internet > WiFi > BLE > LoRa |
| Default (BLE) | BLE > WiFi > LoRa > Internet |

For broadcast messages, implementations MUST send on all available transports.

### BLE (Bluetooth Low Energy)

Each node operates as both a GATT server (peripheral) and GATT client (central) simultaneously. Nodes expose a GATT service with the following characteristics:

| Characteristic | UUID | Purpose |
|---------------|------|---------|
| Mesh TX | `0000A3A1-0000-1000-8000-00805F9B34FB` | Inbound data (write) |
| Mesh RX | `0000A3A2-0000-1000-8000-00805F9B34FB` | Outbound data (notify) |
| Routing ID | `0000A3A3-0000-1000-8000-00805F9B34FB` | Node's 8-byte routing ID (read) |

Service UUID: `0000A3A0-0000-1000-8000-00805F9B34FB`

Default MTU: 512 bytes. Minimum supported MTU: 185 bytes (iOS minimum).

### LoRa (via Meshtastic)

Messages are transmitted over Meshtastic radio using the private application port (`PORTNUM_PRIVATE`, 256). The Meshtastic device handles radio-level framing and encryption independently from the mesh protocol.

Maximum payload per Meshtastic frame: 233 bytes (`DATA_PAYLOAD_LEN`). Messages exceeding this limit are fragmented by the Meshtastic firmware transparently.

Ajna beacons are broadcast on the default text channel for peer discovery. Beacon format:

```
Offset  Size  Field
0x00    1B    BEACON_MARKER (0x01)
0x01    1B    version (0x01)
0x02    8B    routing_id
0x0A    1B    capabilities (CAP_RELAY=0x01, CAP_HAS_INTERNET=0x02)
0x0B    8B    timestamp (big-endian Unix seconds)
```

Total: 19 bytes. Broadcast interval: 30 seconds.

### WiFi

Nodes discover peers on the local network via mDNS service type `_ajna-mesh._tcp.local`. Data is transmitted via UDP datagrams for mesh packets and TCP for large transfers.

WiFi peers are assigned routing IDs with the `WIFI` prefix.

### Internet (WebSocket)

Gateway nodes maintain persistent WebSocket connections to other gateways for cross-cluster message forwarding. Messages on internet transports use full DIDComm JWE encoding for interoperability.

Internet-reachable nodes are assigned routing IDs with the `INET` prefix.

---

## States

```
UNINITIALIZED -> INITIALIZING -> ACTIVE <-> ANNOUNCING
                                        <-> RELAYING
                              -> SHUTTING_DOWN -> UNINITIALIZED
```

| State | Description |
|-------|-------------|
| `uninitialized` | Mesh module not started |
| `initializing` | Generating keys, setting up transports |
| `active` | Listening for announcements, accepting packets |
| `announcing` | Broadcasting announcement (periodic, adaptive interval) |
| `relaying` | Forwarding a received packet to neighbors |
| `shutting_down` | Broadcasting leave notification before shutdown |

---

## Configuration

| Parameter | Default | Description |
|-----------|---------|-------------|
| `default_ttl` | 7 | TTL assigned to new packets |
| `max_hops` | 10 | Maximum route length for directed messages |
| `announce_interval` | adaptive | Time between periodic announcements (see Adaptive Announcement Interval) |
| `route_freshness` | 60s | How long topology entries remain valid |
| `dedup_capacity` | 1000 | Size of deduplication LRU cache |
| `dedup_ttl` | 5min | How long dedup entries persist |
| `fragment_ttl_cap` | 5 | Maximum TTL for fragment packets |
| `high_degree_threshold` | 6 | Peer count above which broadcast TTL is capped |
| `probabilistic_relay` | true | Enable density-based relay probability |
| `binary_encoding` | true | Use binary wire format on constrained transports |
| `compress_enabled` | true | Enable zstd dictionary compression |
| `session_key_ttl` | 24h | How long compact session keys remain valid before re-derivation |
| `gateway_update_retry` | 3 | Retry count for gateway-update notifications |

### Adaptive Announcement Interval

The announcement interval scales with network size to prevent bandwidth saturation on constrained transports:

| Known Peers | Interval | Rationale |
|-------------|----------|-----------|
| 0-5 | 15s | Rapid discovery in small networks |
| 6-20 | 30s | Standard operation |
| 21-50 | 60s | Reduce overhead in larger networks |
| 51+ | 120s | Minimize announcement bandwidth |

---

## Basic Walkthrough

### Local Mesh Communication

1. **Node A** starts mesh, generates Ed25519 keypair, derives routing ID from public key
2. **Node A** begins BLE advertising with its service UUID
3. **Node B** discovers Node A via BLE scan, connects, reads routing ID characteristic
4. **Node B** registers Node A as a peer
5. Both nodes begin periodic `announce` broadcasts containing their routing ID, signing key, and direct neighbor list
6. Upon receiving an announcement, each node verifies the Ed25519 signature and routing ID binding, then updates its topology graph
7. **Node A** sends a DIDComm message to **Node C** (not directly connected). The mesh handler computes a route (A -> B -> C) via BFS, wraps the packed DIDComm message in a compact-envelope `relay` packet with `dest_id=C`, `ttl=7`, and sends to B
8. **Node B** receives the relay, decrements TTL, computes next hop for C, and forwards
9. **Node C** receives the relay, sees `dest_id` matches its routing ID, decrypts the compact envelope, extracts the DIDComm payload, and processes it
10. When **Node A** shuts down, it broadcasts a `leave` message so peers immediately remove it from their topology

### Cross-Cluster Communication via Gateway

1. **Phone A** (Tokyo mesh) wants to send a message to **Laptop C** (Berlin mesh)
2. **Phone A** checks local BFS topology — **Laptop C** is not in the local mesh
3. **Phone A** looks up its ConnectionRecord for **Laptop C** — finds `their_gateway: "wss://berlin-gateway.dev"` (stored during the original OOB key exchange)
4. **Phone A** encrypts the message end-to-end for **Laptop C** (DIDComm JWE, Layer 1)
5. **Phone A** wraps in a DIDComm `forward` envelope addressed to the Berlin gateway (Layer 2), sends to its local **Gateway A** over BLE mesh
6. **Gateway A** decrypts the forwarding layer, connects to `wss://berlin-gateway.dev` via WebSocket, sends the full DIDComm JWE
7. **Gateway B** (Berlin) receives the forward, decrypts the routing layer, looks up **Laptop C** in its local routing table, wraps in a compact mesh envelope, and delivers over BLE mesh
8. **Laptop C** decrypts the compact envelope, then the inner DIDComm JWE — reads the message

End-to-end encryption (Layer 1) is never broken by any gateway or relay node.

---

## Relay Policy

### Decision Order

1. **TTL <= 1 or sender is self**: Do not relay
2. **Handshake messages** (`is_handshake`): Always relay with minimal jitter (10-35ms)
3. **Directed messages** (`is_directed`): Always relay with moderate jitter (20-60ms)
4. **Fragments** (`is_fragment`): Relay with TTL capped at `fragment_ttl_cap`
5. **Broadcasts/Announcements**: Apply probabilistic relay with degree-adaptive jitter and TTL capping

### Degree-Adaptive Jitter

Relay delay scales with peer count to reduce broadcast storms in dense networks:

| Peer Count | Delay Range | Classification |
|------------|-------------|----------------|
| 0-2 | 10-40ms | Sparse |
| 3-5 | 60-150ms | Moderate |
| 6-9 | 80-180ms | Dense |
| 10+ | 100-220ms | Very Dense |

Dense networks (>= `high_degree_threshold` peers) also cap broadcast TTL to 5.

### Probabilistic Relay

When `probabilistic_relay` is enabled, broadcast messages are relayed with a probability that decreases with peer density. This reduces broadcast amplification by 30-65% in dense networks while maintaining high reachability:

| Peer Count | Relay Probability | Rationale |
|------------|-------------------|-----------|
| 0-2 | 100% | Bridge nodes must always relay |
| 3-5 | 70% | Moderate redundancy |
| 6-9 | 50% | Dense — sufficient coverage with partial relay |
| 10+ | 35% | Very dense — high probability of alternate paths |

Directed messages are not subject to probabilistic relay — they are always forwarded.

---

## Gateway Protocol

A gateway node bridges a local mesh cluster to the global internet. Any device that has both a mesh transport (BLE/LoRa) and an internet connection can act as a gateway. Gateways run a DIDComm mediator service and use standard DIDComm forwarding to route messages between clusters.

### Design Principles

- **No public user directory.** No DID is ever published to a global registry or DHT. Users are only reachable by contacts they have explicitly exchanged keys with.
- **Connection-record routing.** Cross-cluster routing uses gateway endpoints stored in ConnectionRecords from the original OOB key exchange. No global lookup is required for normal operation.
- **Standard DIDComm protocols.** Gateways use [Coordinate Mediation 2.0](https://didcomm.org/coordinate-mediation/2.0/) for device registration, [Routing 2.0](https://didcomm.org/routing/2.0/) for forwarding, and [Message Pickup 2.0](https://didcomm.org/messagepickup/2.0/) for store-and-forward.

### Gateway Capabilities

Gateways announce themselves on the local mesh with the `CAP_HAS_INTERNET` (0x02) flag in their announcement or beacon. Mesh devices discover gateways through standard mesh announcements.

### Device Registration

When a mesh device requires global reachability, it registers with a local gateway:

1. Device discovers gateway via mesh announcement (`CAP_HAS_INTERNET` flag)
2. Device sends a [Coordinate Mediation 2.0](https://didcomm.org/coordinate-mediation/2.0/) `mediate-request` to the gateway
3. Gateway grants mediation, returning its `routing_did`
4. Device updates its DID document `serviceEndpoint` to include the gateway's endpoint
5. Gateway adds device's DID and mesh routing ID to its local routing table via `keylist-update`

The gateway's routing table is local only. No information is published to any external system.

### Cross-Cluster Routing

When a device sends a message to a contact in another cluster:

1. Device checks local mesh topology — destination not found
2. Device looks up the contact's `ConnectionRecord` — finds `their_gateway` endpoint (stored during OOB invitation + DID exchange)
3. Device wraps the message in a DIDComm [forward](https://didcomm.org/routing/2.0/) envelope addressed to the remote gateway
4. Device sends the forward envelope to its local gateway over the mesh
5. Local gateway connects to the remote gateway via WebSocket and sends the full DIDComm JWE
6. Remote gateway decrypts the forwarding layer, looks up the recipient in its local routing table, and delivers via mesh

No DHT lookup, blockchain query, or external infrastructure is involved in normal message routing.

### Gateway Change Notification

When a device changes gateways (e.g., moves to a different geographic location):

Message Type URI: `https://didcomm.org/mesh/1.0/gateway-update`

```json
{
    "type": "https://didcomm.org/mesh/1.0/gateway-update",
    "id": "gw-update-a1b2c3",
    "body": {
        "new_gateway": "wss://new-gateway.example.com:4965",
        "timestamp": 1706267100000
    }
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `new_gateway` | string | Yes | WebSocket endpoint of the device's new gateway |
| `timestamp` | number | Yes | Update time (ms since epoch) |

**Processing:**

1. Device registers with new gateway (mediation request)
2. Device sends `gateway-update` to all contacts via the new gateway
3. Each contact updates `ConnectionRecord.their_gateway` upon receipt
4. Implementations SHOULD retry delivery up to `gateway_update_retry` times for unreachable contacts

### Recovery Fallback

When a contact's stored gateway endpoint is unreachable (gateway has failed), implementations MAY use one or more fallback mechanisms:

#### Option A: Routing Token (DHT, privacy-preserving)

A per-contact routing token allows emergency gateway lookup without exposing identity:

```
shared_secret = X25519(our_private, their_public)

routing_token = HKDF-SHA256(
    ikm:    shared_secret,
    salt:   "ajna-routing-token-v1",
    info:   our_did || ":" || their_did,
    length: 32
)

dht_key   = SHA256(routing_token)
dht_value = AES-256-GCM(key=routing_token, plaintext=new_gateway_endpoint)
```

Properties:
- Each contact pair produces a unique DHT key (different ECDH shared secret)
- Only the intended contact can compute the routing token and decrypt the value
- DHT entries cannot be correlated to any identity or to each other
- Entries expire after 24 hours (TTL)

#### Option B: Blockchain DID Re-Resolution

The device updates its DID document on-chain with the new `serviceEndpoint`. Contacts re-resolve the DID from the blockchain to obtain the updated gateway endpoint.

#### Option C: Mutual Contact Relay

A shared contact who has the device's updated gateway relays the new endpoint upon request.

### Store-and-Forward

When a message arrives at a gateway for a device that is currently offline (not on the local mesh):

1. Gateway stores the message using [Message Pickup 2.0](https://didcomm.org/messagepickup/2.0/)
2. When the device reconnects to the mesh, it sends a `delivery-request`
3. Gateway delivers stored messages

### Multi-Gateway Resilience

A device MAY register with multiple gateways simultaneously for redundancy. Contacts attempting delivery try each known gateway in order. If the primary gateway is unreachable, the secondary gateway serves the message.

---

## Security

- **Announcement authentication**: Every announcement is Ed25519-signed. Nodes MUST verify the signature before updating topology
- **Routing ID binding**: `routing_id == SHA256(signing_key)[0..8]`. Nodes MUST verify this binding to prevent ID spoofing
- **Stale announcement rejection**: Announcements older than `dedup_ttl` are silently dropped
- **Deduplication**: LRU cache tracks seen packet/announcement IDs to prevent replay and flooding
- **Payload encryption**: The mesh only transports already-packed (encrypted) DIDComm messages. Relay payloads are opaque to intermediate nodes
- **No DID leakage**: Only 8-byte routing IDs appear in packet headers, never DIDs
- **Session key security**: Compact envelope session keys are derived from the same ECDH shared secret as DIDComm. Compromising a session key requires compromising the underlying X25519 private key
- **Counter replay protection**: Monotonic counters in the compact envelope prevent replay attacks. Receivers MUST reject counters less than or equal to the last seen value
- **Gateway opacity**: Gateways decrypt only the forwarding layer (Layer 2). The inner DIDComm message (Layer 1) is encrypted end-to-end for the final recipient and is opaque to all intermediaries

---

## Message Reference

All mesh messages use the namespace: `https://didcomm.org/mesh/1.0/<message-name>`

---

### announce

Periodic broadcast to advertise presence and share topology.

Message Type URI: `https://didcomm.org/mesh/1.0/announce`

```json
{
    "type": "https://didcomm.org/mesh/1.0/announce",
    "id": "announce-a1b2c3",
    "body": {
        "routing_id": "<8 bytes, base64url>",
        "signing_key": "<32 bytes Ed25519 public key, base64url>",
        "direct_neighbors": [
            "<8 bytes routing_id, base64url>",
            "<8 bytes routing_id, base64url>"
        ],
        "timestamp": 1706266800000,
        "signature": "<64 bytes Ed25519 signature, base64url>"
    }
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `routing_id` | bytes | Yes | 8-byte routing ID derived from `signing_key` |
| `signing_key` | bytes | Yes | 32-byte Ed25519 public key |
| `direct_neighbors` | bytes[] | Yes | Routing IDs of directly connected peers |
| `timestamp` | number | Yes | Milliseconds since Unix epoch |
| `signature` | bytes | Yes | Ed25519 signature over `routing_id \|\| signing_key \|\| neighbors \|\| timestamp` |

**Verification:**
1. Verify `signature` against `signing_key`
2. Verify `routing_id == SHA256(signing_key)[0..8]`
3. Reject if `timestamp` is stale (older than `dedup_ttl`)
4. Reject if already in deduplication cache (key: `routing_id + timestamp`)

On constrained transports, the binary encoding (see [Encoding](#encoding)) is used instead of JSON.

---

### relay

Wraps a packed DIDComm message for multi-hop mesh delivery.

Message Type URI: `https://didcomm.org/mesh/1.0/relay`

```json
{
    "type": "https://didcomm.org/mesh/1.0/relay",
    "id": "relay-d4e5f6",
    "body": {
        "id": "pkt-7a8b9c0d",
        "sender_id": "<8 bytes, base64url>",
        "dest_id": "<8 bytes or null, base64url>",
        "next_hop": "<8 bytes or null, base64url>",
        "ttl": 5,
        "timestamp": 1706266810000,
        "flags": {
            "is_handshake": false,
            "is_directed": true,
            "is_fragment": false,
            "requires_ack": false
        },
        "payload": "<compact envelope or packed DIDComm message>"
    }
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `id` | string | Yes | Unique packet ID for deduplication |
| `sender_id` | bytes | Yes | Originator's 8-byte routing ID |
| `dest_id` | bytes | No | Final destination routing ID. `null` for broadcasts |
| `next_hop` | bytes | No | Next relay hop routing ID. Set by relay nodes using topology |
| `ttl` | number | Yes | Time-to-live, decremented on each relay hop |
| `timestamp` | number | Yes | Packet creation time (ms since epoch) |
| `flags` | object | Yes | Packet handling flags |
| `payload` | string/bytes | Yes | Compact envelope (paired peers) or packed DIDComm JWE (first contact) |

**Flags:**

| Flag | Description |
|------|-------------|
| `is_handshake` | Session-critical message (always relayed, minimal jitter) |
| `is_directed` | Unicast message with a specific destination |
| `is_fragment` | Fragment of a larger message (TTL capped at `fragment_ttl_cap`) |
| `requires_ack` | Sender expects acknowledgment |

**Processing:**
1. Check dedup cache for `id + timestamp` — drop if seen
2. If `dest_id` matches our routing ID: extract `payload`, decrypt compact envelope (if applicable), deliver to agent
3. If `sender_id` is ours: drop (don't relay our own packets)
4. Apply relay policy (see [Relay Policy](#relay-policy))
5. Decrement TTL; for directed messages, compute next hop from topology via BFS; broadcast or forward

On constrained transports, the binary encoding (see [Encoding](#encoding)) is used instead of JSON.

---

### leave

Graceful departure notification.

Message Type URI: `https://didcomm.org/mesh/1.0/leave`

```json
{
    "type": "https://didcomm.org/mesh/1.0/leave",
    "id": "leave-g7h8i9",
    "body": {
        "routing_id": "<8 bytes, base64url>",
        "timestamp": 1706267000000,
        "signature": "<64 bytes Ed25519 signature, base64url>"
    }
}
```

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `routing_id` | bytes | Yes | 8-byte routing ID of the departing node |
| `timestamp` | number | Yes | Departure time (ms since epoch) |
| `signature` | bytes | Yes | Ed25519 signature over `routing_id \|\| timestamp` |

**Processing:**
1. Verify signature against known signing key for this routing ID
2. Remove peer from topology graph
3. Emit peer-lost event

---

### gateway-update

Notification sent to contacts when a device changes gateways.

Message Type URI: `https://didcomm.org/mesh/1.0/gateway-update`

Defined in the [Gateway Protocol](#gateway-protocol) section.

---

## Topology

Each node maintains a distributed topology graph tracking:
- **Direct neighbors**: Peers within direct transport range
- **Announced neighbors**: Neighbor lists received via announcements from multi-hop peers

### Route Computation

Routes are computed on-demand using BFS over the topology graph, limited to `max_hops`.

Only **bidirectionally confirmed** edges are used for routing — both peers must claim each other as neighbors in their respective announcements. Unidirectional links are excluded to prevent routing through asymmetric connections.

### Freshness

Topology entries expire after `route_freshness` and are pruned periodically. A node whose announcements have not been received within the freshness window is excluded from route computation.

### Routing Strategy

For directed messages with a known destination:
1. Compute BFS shortest path from sender to destination
2. If a route is found: send to next hop via `send_to(next_hop, packet)`
3. If no route is found and topology is still forming (< 80% bidirectionally confirmed edges): fall back to broadcast
4. If no route is found and topology is stable: fail with no-route error

For broadcast messages: flood to all neighbors on all transports, subject to relay policy.

---

## Fragmentation

For messages exceeding the transport MTU (typically 512 bytes for BLE, ~200 bytes for LoRa):

1. Sender splits the packed message into fragments
2. Each fragment is sent as a `relay` packet with `is_fragment: true`
3. Fragment TTL is capped at `fragment_ttl_cap` to prevent flood amplification
4. Receiver assembles fragments using the packet ID and sequence numbers
5. Assembly times out after 30s; maximum 128 concurrent assemblies

Fragment header (BLE):

```
Offset  Size  Field
0x00    8B    message_id
0x08    2B    fragment_index
0x0A    2B    total_fragments
0x0C    1B    flags
```

Total header: 13 bytes.

---

## Composition

| Protocol | Composition |
|----------|-------------|
| [Out-of-Band 2.0](https://didcomm.org/out-of-band/2.0/) | First contact and key exchange. Gateway endpoints included in service list |
| [DID Exchange 1.1](https://didcomm.org/didexchange/1.1/) | Connection establishment messages transported over mesh relay |
| [BasicMessage 2.0](https://didcomm.org/basicmessage/2.0/) | Chat messages between mesh peers |
| [Trust Ping 2.0](https://didcomm.org/trust-ping/2.0/) | Liveness checks over mesh |
| [Coordinate Mediation 2.0](https://didcomm.org/coordinate-mediation/2.0/) | Device registration with gateway nodes |
| [Routing 2.0](https://didcomm.org/routing/2.0/) | Cross-cluster message forwarding between gateways |
| [Message Pickup 2.0](https://didcomm.org/messagepickup/2.0/) | Store-and-forward for offline mesh devices at gateways |

---

## Privacy

### Mesh Layer

- Intermediate relay nodes cannot read message payloads (DIDComm end-to-end encryption)
- Only compact 8-byte routing IDs appear in packet headers, never DIDs
- Routing IDs are SHA256 hashes of public keys, not reversible to identity
- Announcements reveal routing IDs, signing keys, and neighbor topology (inherent to mesh discovery)
- Identity and connection establishment are handled via the OOB protocol, keeping DIDs out of the broadcast mesh layer

### Gateway Layer

- Gateway nodes decrypt only the forwarding envelope (Layer 2) to determine the next hop. The inner message (Layer 1) remains encrypted for the final recipient
- A device's gateway endpoint is shared only with explicit contacts during OOB key exchange, not published to any global directory
- No DID is ever stored in a DHT, blockchain registry, or any other public system for the purpose of routing
- Each contact knows only the device's gateway endpoint, not the device's other contacts or their gateways

### Recovery Fallback

- DHT routing tokens are per-contact (different ECDH shared secret per pair), preventing correlation
- DHT values are encrypted; only the intended contact can decrypt the gateway endpoint
- DHT entries expire after 24 hours and contain no identity information
- Blockchain DID documents are opt-in; mesh-only users need not anchor their DID on-chain

### Anti-Spam

- Users are only reachable by contacts who possess their X25519 public key from a prior key exchange
- There is no mechanism to discover or message arbitrary DIDs. First contact requires an explicit out-of-band introduction (QR code, shared link, physical proximity)
- Gateway mediators only accept forwarded messages addressed to DIDs in their registered keylist

---

## Implementations

- [Ajna Browser](https://ajna.inc)

---

## Endnotes

### Future Considerations

- Encrypted announcements (hide topology from passive observers)
- Gossip-based topology synchronization as alternative to full-flood announcements
- Quality-of-service routing (latency-aware, bandwidth-aware path selection)
- Group messaging with mesh multicast
- Mesh network partitioning detection and recovery
- Incentive mechanisms for relay and gateway operators
- Formal verification of the routing token privacy model
